## 백트래킹(BackTracking)이란?
> 해를 찾는 도중 해가 절대 될 수 없다고 판단되면, 되돌아가서 해를 다시 찾아가는 기법을 말한다.

제한 조건에 위배가 되는지 판단하고, 해당 상태가 위배되는 경우 해당 상태를 제외하고 다음 단계로 넘어간다.
여기서 **KEY POINT**는 **더 이상 탐색할 필요가 없는 상태를 제외한다는 것**인데, 이를 **가지치기**라고 한다.

모든 경우의 수를 전부 고려하는 알고리즘. **상태공간을 트리**로 나타낼 수 있을 때 적합한 방식이다. 
일종의 **트리 탐색 알고리즘**이라고 봐도 된다. 방식에 따라서 깊이우선탐색(DFS)과 너비우선탐색(BFS), 최선 우선 탐색(Best First Search/Heuristic Search)이 있다. 복잡한 고려 없이 쉽게 짤 수 있다는 것이 장점이다.

모든 경우의 수를 고려해야 하는 문제라면, DFS가 낫다. 경우의 수 구하기는 일반적으로 DFS가 편리하다. 대다수의 문제들은 DFS를 써도 답은 나온다.

### [DFS : 깊이 우선 탐색]

DFS는 상태공간을 나타낸 트리에서 바닥에 도달할 때까지 한쪽 방향으로만 내려가는 방식이다. 
한 방향으로 들어갔다가 막다른 길에 다다르면(=트리의 바닥에 도착) 왔던 길을 돌아가서 다른 방향으로 간다. 목표지점(=원하는 해)이 나올 때까지 이를 반복한다.
재귀함수로 구현할 수 있으며, 재귀함수에 익숙하지 않다면 스택을 써서 할 수도 있다.

DFS를 절대 쓰면 안 되는 경우가 있는데, **트리의 깊이가 무한대**가 될 때이다. 
미로찾기에서 루프(회로)가 발생하는 경우, DFS는 이 가지를 탈출할 수 없게 된다. 물론 중복검사를 막기 위한 장치를 넣을 수도 있지만, 그럴 바에는 BFS가 편하다. 
또 분기점 없이 길이만 죽어라 긴 길이 나타나면 스택 오버플로가 발생할 수 있다. 그리고 최단거리 구하기에서는 BFS를 사용하는 게 편리하다.

사용 예시 : 트리 순회, 경로 탐색, 완전탐색
```python
    def dfs(graph, v, visited):
        visited[v] = True
        print(v, end=' ')
        
        for neighbor in graph[v]:
            if not visited[neighbor]:
                dfs(graph, neighbor, visited)

    # 예제 그래프 (노드 번호는 1부터 시작)
    graph = {
        1: [2, 3],
        2: [4, 5],
        3: [],
        4: [],
        5: []
    }

    visited = [False] * (len(graph) + 1)
    dfs(graph, 1, visited)
```

### [BFS : 넓이 우선 탐색]

BFS는 **모든 분기점을 다 검사**하면서 진행하는 방식이다. 
철수와 영희가 계단에서 가위바위보를 하며 게임을 하고 있을 때, 철수가 원하는 지점에 갈 수 있는 최소 승리 횟수는 얼마인가? 같은 문제에서 효과를 발휘한다.
이 경우 DFS는 깊이가 무한인 경우에 빠져나오지 못하며, 중복 방지를 한다고 치더라도 올바른 해를 찾는데 시간이 많이 걸린다. 
BFS는 모든 분기를 다 검색하면서 상태공간을 탐색한다. 철수가 이겼을 때, 비겼을 때, 졌을 때를 검사하고, 그 경우마다 각각 또다른 3가지 가능성을 전부 검사한다. 
이러다가 어느 한 부분에서 원하는 해를 발견하면, 이것이 최단 거리가 된다.

BFS는 **큐**를 써서 구현한다. 각 경우를 검사하면서 발생하는 새로운 경우를 큐에 집어넣고, 검사한 원소는 큐에서 뺀다.
BFS의 장점은 DFS가 못 건드리는 문제를 풀 수 있는 것이지만, **공간 복잡도가 지수 스케일로 증가**하기 때문에 가지치기를 제대로 안하면 DFS보다 빨리 오버플로에 다다를 수 있다.

사용 예시 : 미로, 퍼뜨리기, 레벨 구조
```python
    from collections import deque

    def bfs(graph, start):
        visited = [False] * (len(graph) + 1)
        queue = deque([start])
        visited[start] = True
        
        while queue:
            v = queue.popleft()
            print(v, end=' ')
            
            for neighbor in graph[v]:
                if not visited[neighbor]:
                    queue.append(neighbor)
                    visited[neighbor] = True

    # 예제 그래프
    graph = {
        1: [2, 3],
        2: [4, 5],
        3: [],
        4: [],
        5: []
    }

    bfs(graph, 1)
```

### [Best First Search]

이 BFS에서 조금 더 발전한 방식이 Best First Search 방식이다. **큐 대신 우선순위 큐(보통은 힙)를 써서 구현**하는데, 
발생하는 새로운 경우를 순차적으로 검사하는 넓이 우선 탐색과는 달리 현재 가장 최적인 경우를 우선적으로 검사하므로 상대적으로 효율적이다.
백트래킹은 모든 경우를 다 고려하기 때문에 이걸 쓰면 어지간해서는 해결할 수도 있다. 다이나믹 프로그래밍으로 할 수 있는 것도 다 구현할 수 있으니 시간과 메모리만 해결하면 매우 유용하다. 
해결하지 못했을 때 시간이 많이 걸려서 그렇지. 또한 무의미한 탐색을 막아줄 가지치기(Bounded(Promising) function)를 적용하여 적당한 지능(Heuristic)을 부여한다면 상당히 효과적인 해결방법이 될 수 있다. 

아까 본 철수 영희 문제의 경우, 목적지점과 계속 반대로 가려는 가지는 굳이 탐색할 필요가 없으므로, 적절히 쳐내면 된다. 
이렇게 하면 전혀 가망이 없는 경우로의 탐색이 이루어지지 않으므로 계산 성능이 향상된다.

사용 예시 : A*, 경로 탐색, 최적화 문제